<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Knitting Pattern Maker</title>

<style>
body {
    font-family: Arial, sans-serif;
    background: #f4f4f4;
    padding: 20px;
    text-align: center;
}

.controls {
    margin-bottom: 15px;
}

input, select, button {
    padding: 6px;
    margin: 4px;
}

#grid {
    display: inline-grid;
    gap: 2px;
    background: #ccc;
    padding: 5px;
}

.cell {
    width: 32px;
    height: 32px;
    background: white;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 12px;
    font-weight: bold;
    user-select: none;
    border: 1px solid #eee;
}

.cell:hover {
    outline: 2px solid #87ceeb;
}

textarea {
    width: 95%;
    height: 180px;
    margin-top: 15px;
}

.mode-active {
    background: #007bff;
    color: white;
}
#legend {
    margin-top: 10px;
    display: flex;
    justify-content: center;
    gap: 15px;
    flex-wrap: wrap;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 14px;
}

.legend-color-box {
    width: 20px;
    height: 20px;
    border: 1px solid #000;
}

#gridViewport {
    width: 100%;
    height: 70vh;
    border: 1px solid #aaa;
    overflow: auto;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    background: #eaeaea;
}

</style>
</head>

<body>

<h1>ðŸ§¶ Knitting Pattern Maker</h1>

<div class="controls">
    Rows: <input type="number" id="rows" value="12" min="1" max="200">
    Columns: <input type="number" id="cols" value="12" min="1" max="200">
    <button onclick="createGrid()">Create Grid</button>
    <br>

    <button id="stitchModeBtn" onclick="setMode('stitch')" class="mode-active">Stitch Mode</button>
    <button id="colorModeBtn" onclick="setMode('color')">Color Mode</button>
    <br>
    <button onclick="zoomIn()">Zoom In</button>
    <button onclick="zoomOut()">Zoom Out</button>
    <button onclick="resetZoom()">Reset Zoom</button>

    <br>

    <div id="stitchControls">
        Stitch:
        <select id="stitchType">
            <option value="K">K</option>
            <option value="P">P</option>
            <option value="YO">YO</option>
            <option value="SSK">SSK</option>
            <option value="K2T">K2T</option>
            <option value="">Clear Stitch</option>
        </select>
    </div>

    <div id="colorControls" style="display:none;">
        Color:
        <input type="color" id="colorPicker" value="#ff0000">
        <button onclick="clearSelectedColor()">Clear Color</button>
    </div>

    <br>
    <button onclick="exportPattern()">Export Pattern</button>
    <button onclick="exportPDF()">Export PDF</button>
    <button onclick="exportPNG()">Export PNG</button>

    <br><br>
    Project Name:
    <input type="text" id="projectName" value="My Pattern">

    <button onclick="saveProjectFile()">Save to File</button>
    <button onclick="loadProjectFile()">Load from File</button>
    <button onclick="saveToBrowser()">Save to Browser</button>
    <button onclick="loadFromBrowser()">Load from Browser</button>

    <input type="file" id="fileLoader" style="display:none" />

</div>

<div id="gridViewport">
    <div id="grid"></div>
</div>

<h3>Color Legend</h3>
<div id="legend"></div>

<textarea id="output" placeholder="Pattern export will appear here..."></textarea>

<script>
let pattern = [];
let currentMode = "stitch";
let colorRegistry = {}; 

let isMouseDown = false;
let undoStack = [];

let baseCellSize = 32;
let zoomLevel = 1;
const MIN_ZOOM = 0.1;
const MAX_ZOOM = 3;



const MAX_UNDO = 100;

// ============================
// MODE SWITCH
// ============================

function setMode(mode) {
    currentMode = mode;

    document.getElementById("stitchControls").style.display =
        mode === "stitch" ? "block" : "none";

    document.getElementById("colorControls").style.display =
        mode === "color" ? "block" : "none";

    document.getElementById("stitchModeBtn").classList.toggle("mode-active", mode === "stitch");
    document.getElementById("colorModeBtn").classList.toggle("mode-active", mode === "color");
}

// ============================
// GRID CREATION
// ============================

function createGrid() {
    const rows = parseInt(document.getElementById("rows").value);
    const cols = parseInt(document.getElementById("cols").value);

    undoStack = [];
    colorRegistry = {};

    buildEmptyGrid(rows, cols);
    generateLegend();
    updateGridSizing(cols);
    applyZoom();
}


document.addEventListener("mouseup", () => {
    isMouseDown = false;
});

// ============================
// PAINTING
// ============================

function paintCell(cell, r, c) {

    if (currentMode === "stitch") {
        const stitch = document.getElementById("stitchType").value;
        pattern[r][c].stitch = stitch;
        cell.textContent = stitch;
    }

    if (currentMode === "color") {
        const color = document.getElementById("colorPicker").value;
        pattern[r][c].color = color;
        cell.style.backgroundColor = color;
        cell.style.color = getContrastColor(color);
    }
    generateLegend();
}

// ============================
// UNDO SYSTEM
// ============================

function saveState() {
    const snapshot = JSON.parse(JSON.stringify(pattern));
    undoStack.push(snapshot);

    if (undoStack.length > MAX_UNDO) {
        undoStack.shift();
    }
}

function undo() {
    if (undoStack.length === 0) return;

    pattern = undoStack.pop();
    redrawGrid();
}

// Ctrl + Z support
document.addEventListener("keydown", function(e) {
    if (e.ctrlKey && e.key === "z") {
        undo();
    }
});

// ============================
// REDRAW
// ============================

function redrawGrid() {
    const cells = document.querySelectorAll(".cell");

    cells.forEach(cell => {
        const r = parseInt(cell.dataset.row);
        const c = parseInt(cell.dataset.col);

        const data = pattern[r][c];

        cell.textContent = data.stitch || "";
        cell.style.backgroundColor = data.color || "white";
        cell.style.color = data.color
            ? getContrastColor(data.color)
            : "black";
    });
    generateLegend();
}

// ============================
// CONTRAST
// ============================

function getContrastColor(hexColor) {

    const hex = hexColor.replace("#", "");

    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);

    const luminance = (0.299 * r + 0.587 * g + 0.114 * b);

    return luminance > 150 ? "black" : "white";
}

// ============================
// EXPORT
// ============================

function exportPattern() {
    const output = document.getElementById("output");

    let textExport = "Knitting Pattern:\n\n";

    for (let r = pattern.length - 1; r >= 0; r--) {
        textExport += `Row ${r + 1}: `;
        textExport += pattern[r].map(cell => {
            let part = "";
            if (cell.stitch) part += cell.stitch;
            if (cell.color) {
                const colors = getColorMap();
                const entry = colors[cell.color];
                part += `(${entry.letter})`;
            }
            if (!part) part = "-";
            return part;
        }).join(" ");
        textExport += "\n";
    }

    output.value = textExport + "\n\nJSON:\n" +
        JSON.stringify(pattern, null, 2);
        textExport += "\nColor Legend:\n";

    Object.keys(colorRegistry).forEach(color => {
        const entry = colorRegistry[color];
        textExport += `${entry.letter}: ${entry.name} (${color})\n`;
    });
}

function generateLegend() {
    const legendContainer = document.getElementById("legend");
    legendContainer.innerHTML = "";

    const uniqueColors = new Set();

    pattern.forEach(row => {
        row.forEach(cell => {
            if (cell.color) uniqueColors.add(cell.color);
        });
    });

    const colors = Array.from(uniqueColors);

    colors.forEach((color, index) => {

        // Assign letter if new
        if (!colorRegistry[color]) {
            const letter = String.fromCharCode(65 + Object.keys(colorRegistry).length);
            colorRegistry[color] = {
                letter: letter,
                name: `Color ${letter}`
            };
        }

        const item = document.createElement("div");
        item.classList.add("legend-item");

        const box = document.createElement("div");
        box.classList.add("legend-color-box");
        box.style.backgroundColor = color;

        const label = document.createElement("span");
        label.textContent = colorRegistry[color].letter;

        const input = document.createElement("input");
        input.type = "text";
        input.value = colorRegistry[color].name;
        input.style.width = "120px";

        input.addEventListener("input", (e) => {
            colorRegistry[color].name = e.target.value;
        });

        item.appendChild(box);
        item.appendChild(label);
        item.appendChild(input);

        legendContainer.appendChild(item);
    });
}

function getColorMap() {
    const map = {};

    Object.keys(colorRegistry).forEach(color => {
        map[color] = colorRegistry[color];
    });

    return map;
}

async function exportPDF() {
    const { jsPDF } = window.jspdf;

    const rows = pattern.length;
    const cols = pattern[0].length;

    const margin = 20;

    // ===============================
    // PAGE 1 â€“ SCALED OVERVIEW
    // ===============================

    const overviewDoc = new jsPDF();
    const pageWidth = overviewDoc.internal.pageSize.getWidth();
    const pageHeight = overviewDoc.internal.pageSize.getHeight();

    const usableWidth = pageWidth - margin * 2;
    const usableHeight = pageHeight - margin * 3;

    const cellSizeOverview = Math.floor(
        Math.min(usableWidth / cols, usableHeight / rows)
    );

    overviewDoc.setFontSize(16);
    overviewDoc.text("Knitting Pattern â€“ Overview", margin, margin);

    drawChart(
        overviewDoc,
        cellSizeOverview,
        margin,
        margin + 10,
        rows,
        cols,
        true
    );

    drawLegend(overviewDoc, margin, margin + 20 + rows * cellSizeOverview);

    // ===============================
    // TILE PAGES â€“ FULL RESOLUTION
    // ===============================

    const tileCellSize = 15; // fixed readable working size
    const tileDoc = overviewDoc;

    const tilePageWidth = tileDoc.internal.pageSize.getWidth();
    const tilePageHeight = tileDoc.internal.pageSize.getHeight();

    const maxColsPerPage = Math.floor((tilePageWidth - margin * 2) / tileCellSize);
    const maxRowsPerPage = Math.floor((tilePageHeight - margin * 2) / tileCellSize);

    for (let rowStart = 0; rowStart < rows; rowStart += maxRowsPerPage) {
        for (let colStart = 0; colStart < cols; colStart += maxColsPerPage) {

            tileDoc.addPage();

            const rowEnd = Math.min(rowStart + maxRowsPerPage, rows);
            const colEnd = Math.min(colStart + maxColsPerPage, cols);

            tileDoc.setFontSize(14);
            tileDoc.text(
                `Rows ${rows - rowEnd + 1}â€“${rows - rowStart} | Cols ${colStart + 1}â€“${colEnd}`,
                margin,
                margin - 5
            );

            drawChartTile(
                tileDoc,
                tileCellSize,
                margin,
                margin,
                rowStart,
                rowEnd,
                colStart,
                colEnd
            );
        }
    }

    tileDoc.save("knitting-pattern.pdf");
}

function drawChartTile(doc, cellSize, startX, startY, rowStart, rowEnd, colStart, colEnd) {

    for (let r = rowStart; r < rowEnd; r++) {
        for (let c = colStart; c < colEnd; c++) {

            const visualRow = pattern.length - 1 - r;

            const cell = pattern[visualRow][c];

            const x = startX + (c - colStart) * cellSize;
            const y = startY + (r - rowStart) * cellSize;

            drawSingleCell(doc, cell, x, y, cellSize);
        }
    }
}

function drawSingleCell(doc, cell, x, y, size) {

    if (cell.color) {
        const rgb = hexToRgb(cell.color);
        doc.setFillColor(rgb.r, rgb.g, rgb.b);
        doc.rect(x, y, size, size, "F");
    }

    doc.setDrawColor(0);
    doc.rect(x, y, size, size);

    if (cell.stitch) {
        doc.setFontSize(size * 0.6);

        if (cell.color) {
            const textColor = getContrastColor(cell.color);
            doc.setTextColor(textColor === "white" ? 255 : 0);
        } else {
            doc.setTextColor(0);
        }

        doc.text(
            cell.stitch,
            x + size / 2,
            y + size / 2 + size * 0.25,
            { align: "center" }
        );
    }
}

function exportPNG() {

    const rows = pattern.length;
    const cols = pattern[0].length;

    const scale = 40; // pixel size per cell (adjust for resolution)
    const padding = 50;

    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    canvas.width = cols * scale + padding * 2;
    canvas.height = rows * scale + padding * 2 + 120; // extra space for legend

    // Background
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Title
    ctx.fillStyle = "#000";
    ctx.font = "24px Arial";
    ctx.fillText("Knitting Pattern", padding, 35);

    // Draw chart
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {

            const cell = pattern[rows - 1 - r][c];

            const x = padding + c * scale;
            const y = padding + r * scale;

            // Fill color
            if (cell.color) {
                ctx.fillStyle = cell.color;
                ctx.fillRect(x, y, scale, scale);
            }

            // Border
            ctx.strokeStyle = "#000";
            ctx.strokeRect(x, y, scale, scale);

            // Stitch text
            if (cell.stitch) {

                if (cell.color) {
                    ctx.fillStyle = getContrastColor(cell.color);
                } else {
                    ctx.fillStyle = "#000";
                }

                ctx.font = `${scale * 0.5}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";

                ctx.fillText(
                    cell.stitch,
                    x + scale / 2,
                    y + scale / 2
                );
            }
        }
    }

    // Draw Legend
    let legendY = padding + rows * scale + 40;

    ctx.fillStyle = "#000";
    ctx.font = "18px Arial";
    ctx.fillText("Color Legend:", padding, legendY);

    legendY += 25;

    Object.keys(colorRegistry).forEach(color => {

        const entry = colorRegistry[color];

        // Color box
        ctx.fillStyle = color;
        ctx.fillRect(padding, legendY - 15, 20, 20);

        ctx.strokeStyle = "#000";
        ctx.strokeRect(padding, legendY - 15, 20, 20);

        // Text
        ctx.fillStyle = "#000";
        ctx.font = "16px Arial";
        ctx.fillText(
            `${entry.letter}: ${entry.name} (${color})`,
            padding + 35,
            legendY
        );

        legendY += 30;
    });

    // Download PNG
    const link = document.createElement("a");
    link.download = "knitting-pattern.png";
    link.href = canvas.toDataURL("image/png");
    link.click();
}

function saveProjectFile() {

    const project = {
        name: document.getElementById("projectName").value,
        rows: pattern.length,
        cols: pattern[0].length,
        pattern: pattern,
        colorRegistry: colorRegistry
    };

    const blob = new Blob(
        [JSON.stringify(project, null, 2)],
        { type: "application/json" }
    );

    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = project.name.replace(/\s+/g, "_") + ".knitjson";
    link.click();
}

function loadProjectFile() {
    document.getElementById("fileLoader").click();
}

document.getElementById("fileLoader").addEventListener("change", function(event) {

    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();

    reader.onload = function(e) {
        const project = JSON.parse(e.target.result);
        restoreProject(project);
    };

    reader.readAsText(file);
});

function saveToBrowser() {

    const project = {
        name: document.getElementById("projectName").value,
        rows: pattern.length,
        cols: pattern[0].length,
        pattern: pattern,
        colorRegistry: colorRegistry
    };

    localStorage.setItem("knittingProject", JSON.stringify(project));

    alert("Project saved to browser.");
}

function loadFromBrowser() {

    const data = localStorage.getItem("knittingProject");

    if (!data) {
        alert("No saved project found.");
        return;
    }

    const project = JSON.parse(data);
    restoreProject(project);
}

function restoreProject(project) {

    // Set UI fields first
    document.getElementById("projectName").value = project.name;
    document.getElementById("rows").value = project.rows;
    document.getElementById("cols").value = project.cols;

    // Reset undo stack
    undoStack = [];

    // Rebuild empty grid structure
    buildEmptyGrid(project.rows, project.cols);

    // Inject saved data
    pattern = project.pattern;
    colorRegistry = project.colorRegistry || {};

    // Redraw everything
    redrawGrid();
    generateLegend();
    applyZoom();
}

function buildEmptyGrid(rows, cols) {

    const grid = document.getElementById("grid");
    grid.innerHTML = "";
    updateGridSizing(cols);

    pattern = [];

    for (let r = 0; r < rows; r++) {
        pattern[r] = [];
        for (let c = 0; c < cols; c++) {

            pattern[r][c] = { stitch: "", color: "" };

            const cell = document.createElement("div");
            cell.classList.add("cell");
            cell.dataset.row = r;
            cell.dataset.col = c;

            cell.addEventListener("mousedown", (e) => {
                isMouseDown = true;
                saveState();
                paintCell(cell, r, c);
            });

            cell.addEventListener("mouseenter", () => {
                if (isMouseDown) {
                    paintCell(cell, r, c);
                }
            });

            grid.appendChild(cell);
        }
    }
}

function updateGridSizing(cols) {

    const grid = document.getElementById("grid");

    const cellSize = baseCellSize * zoomLevel;

    grid.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;

    const cells = document.querySelectorAll(".cell");

    cells.forEach(cell => {
        cell.style.width = `${cellSize}px`;
        cell.style.height = `${cellSize}px`;
        cell.style.fontSize = `${cellSize * 0.4}px`;
    });
}

function zoomIn() {
    zoomLevel = Math.min(MAX_ZOOM, zoomLevel + 0.1);
    applyZoom();
}

function zoomOut() {
    zoomLevel = Math.max(MIN_ZOOM, zoomLevel - 0.1);
    applyZoom();
}

function resetZoom() {
    zoomLevel = 1;
    applyZoom();
}

function applyZoom() {
    const cols = pattern[0].length;
    updateGridSizing(cols);
}


document.getElementById("gridViewport").addEventListener("wheel", function(e) {
    if (e.ctrlKey) {
        e.preventDefault();
        if (e.deltaY < 0) zoomIn();
        else zoomOut();
    }
});

function drawLegend(doc, x, yStart) {

    let y = yStart + 10;

    doc.setFontSize(12);
    doc.setTextColor(0);
    doc.text("Color Legend:", x, y);

    y += 8;

    Object.keys(colorRegistry).forEach(color => {

        const entry = colorRegistry[color];
        const rgb = hexToRgb(color);

        doc.setFillColor(rgb.r, rgb.g, rgb.b);
        doc.rect(x, y - 5, 6, 6, "F");
        doc.setDrawColor(0);
        doc.rect(x, y - 5, 6, 6);

        doc.text(
            `${entry.letter}: ${entry.name} (${color})`,
            x + 12,
            y
        );

        y += 8;
    });
}

function hexToRgb(hex) {
    const clean = hex.replace("#", "");
    return {
        r: parseInt(clean.substring(0, 2), 16),
        g: parseInt(clean.substring(2, 4), 16),
        b: parseInt(clean.substring(4, 6), 16)
    };
}

function drawChart(doc, cellSize, startX, startY, rows, cols) {

    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {

            const cell = pattern[rows - 1 - r][c];

            const x = startX + c * cellSize;
            const y = startY + r * cellSize;

            drawSingleCell(doc, cell, x, y, cellSize);
        }
    }
}

createGrid();
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

</body>
</html>
